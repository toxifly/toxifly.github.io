# Project Instructions

## Overview

This project is a web-based card game, likely a roguelike deck-builder, involving a client (built with React/Vite) and a server (built with Node.js/Express/WebSocket) potentially using the Games Fun SDK. The client handles presentation and user interaction, while the server manages game state, logic, and rules. **The player's turn proceeds automatically, playing cards sequentially as long as the player has enough energy for the `nextCard`. The turn only ends and passes to the enemy when the player cannot afford the cost of their `nextCard` or has no cards left to draw.**
Update this file every time you edit something or you notice that the content is different than what you'd expect based on this description.

## File Structure
.
├── client/ # Frontend React application (Vite) - Responsible for displaying the game state received from the server and sending user actions back.
│   ├── node_modules/ # Project dependencies for the client (React, Vite plugins, etc.).
│   ├── public/ # Static assets accessible directly by the browser (e.g., favicon, initial images).
│   ├── src/    # Client-side source code (React components, context providers, API/WebSocket communication logic, styles).
│   │   ├── App.tsx # The main application component. It wraps the application with `GamesFunProvider` from `@games-fun/react`. **It configures the provider using `GamesFunProviderProps`, setting `debug: true`, enabling `dev` mode, and crucially specifying `gameServerUrl: 'http://localhost:3001/api/validate-action'` to ensure the SDK sends action validation requests to the correct backend endpoint.** It also wraps the core `Game` component with the `GameProvider` for WebSocket context.
│   │   ├── Game.tsx # The core component responsible for rendering the game interface. Uses `useGame` for state/config and `useGamesFunActions` for actions. Manages loading/error/connection states via early returns. Conditionally renders UI based on `gameState.phase` (renders `GameUI` for 'pre_battle' and 'fighting', `RewardScreen` for 'reward', and a 'Game Over' display for 'gameOver' showing floor and currency). Handles the 'pre_battle' phase by rendering the core UI and the `ActionPanel` component. **It includes a `useEffect` hook (dependent on `gameState`, `gameConfig`, and `actions`) to automatically trigger the player's next card play (`actions.autoPlayCard`) after a delay (e.g., 1200ms). This effect triggers when it's the player's turn, they are in the 'fighting' phase, they have a `nextCard` ID (string) available in `gameState.player`, and have sufficient energy for that card. If the server successfully processes the card play and the player *still* has enough energy for the *new* `nextCard`, the `gameState` update will re-trigger this effect, allowing for consecutive card plays within the same logical turn. The effect uses a `useRef` (`gameStateRef`) to capture the latest state for the timeout callback and another `useRef` (`timeoutRef`) along with a robust cleanup function to clear pending timeouts, preventing concurrent or stale actions. The `animatingCardId` state (storing the string card ID) is set before the timeout is scheduled to initiate animation early; this ID is passed down to `GameUI`. Inside the `setTimeout` callback, it re-validates the game state conditions (phase, turn, next card ID, energy) using the `gameStateRef` before calling the `autoPlayCard` action. A `finally` block ensures `animatingCardId` is reset.** Includes extensive console logging. Renders the `ActionPanel` component. Manages `isDeckVisible` state for the `DeckView` modal.
│   │   ├── components/ # Reusable UI components.
│   │   │   ├── GameUI.tsx # The main UI displayed during the 'fighting' phase (and partially in 'pre_battle'). Takes the current `GameState` and `animatingCardId` (string ID) as props. Arranges `PlayerDisplay` and `EnemyDisplay` side-by-side at the top, with the card display area below. **Fetches `gameConfig` using the `useGame` hook. Looks up the `CardDefinition` for the player's next card using the `gameState.player.nextCard` ID string and the fetched `gameConfig`. Passes this `CardDefinition` object to the `CardDisplay` for the next card. Determines `isBeingPlayed` for the `CardDisplay` by comparing the received `animatingCardId` prop with the `gameState.player.nextCard` ID string.** Passes relevant state (including `lastEnemyCardPlayedId`) and `gameConfig` to `EnemyDisplay`. Includes `useEffect` hooks for logging.
│   │   │   ├── CombatantDisplay.tsx # Displays core combatant stats (HP, Block, Momentum) and any active buffs/debuffs (using BuffIcon) based on a CombatantState object. Intended for reuse by PlayerDisplay and EnemyDisplay. Displays buffs from `combatant.buffs` array.
│   │   │   ├── PlayerDisplay.tsx # Displays the player's specific stats, leveraging the CombatantDisplay component and adding player-specific information like energy. Takes a `PlayerState` object as a prop. **Now typically displayed on the left side of the combat area in `GameUI`.**
│   │   │   ├── EnemyDisplay.tsx # Displays the enemy's stats by wrapping CombatantDisplay. It adds a specific background image for the enemy based on `enemy.id`. **Now typically displayed on the right side of the combat area in `GameUI`. Accepts optional `lastPlayedCardId` and `gameConfig` props. Uses a `useEffect` hook to detect changes in `lastPlayedCardId`. If an ID is provided, it looks up the `CardDefinition` in `gameConfig.cards`, displays the card using `CardDisplay` positioned below the enemy stats, makes it visible, and sets a timeout (e.g., 1.5s) to fade it out. Includes logic to hide the card immediately if `lastPlayedCardId` becomes null before the timeout completes or if the card definition is not found.** Takes an `EnemyState` object as the primary prop.
│   │   │   ├── BuffIcon.tsx # Displays an icon for a given Buff, showing its name, description, stacks, and duration on hover. Uses images from `public/images/buffs/` based on the buff ID.
│   │   │   ├── CardDisplay.tsx # Renders a single card based on `CardDefinition`. Displays cost, name, description, and image. Now uses CSS Modules (`CardDisplay.module.css`) for styling. Accepts `card` (a `CardDefinition` object), `isNextCard`, and `isBeingPlayed` props. The `isBeingPlayed` prop (driven by the comparison of `animatingCardId` and `nextCardId` in `GameUI`) triggers a CSS animation defined in the module. Includes console logging.
│   │   │   ├── CardDisplay.module.css # CSS Module defining styles and a `playCardAnimation` keyframe animation for the `CardDisplay` component. Includes base styles, `nextCard` highlight, and `playing` animation class.
│   │   │   ├── RewardScreen.tsx # Displays the card reward options presented to the player after winning a fight (when `gameState.phase === 'reward'`). It fetches the current reward set from `gameState.rewardOptions[gameState.currentRewardSet]` via the `useGame` hook. It uses the `CardDisplay` component to show each card choice. Clicking a card or the "Skip Reward" button triggers the `actions.selectReward` function (obtained via `useGamesFunActions`) with the appropriate `cardIndex` payload. Includes basic inline styling for layout.
│   │   │   ├── ActionPanel.tsx # Renders buttons for player actions outside the main card play area (e.g., fixed position panel). Accepts `gameState`, `actions` (from `useGamesFunActions`), and `onViewDeck` (from `Game.tsx`) as props. Conditionally renders a "Start Battle" button when `gameState.phase === 'pre_battle'`, which calls `actions.startBattle({})`. **Does NOT include an "End Turn" button, as turns progress automatically based on player energy and available cards.** Includes a "View Deck" button. Includes basic inline styles.
│   │   │   ├── ActionPanel.module.css # CSS Module defining styles for the `ActionPanel` component.
│   │   │   ├── DeckView.tsx # A modal/overlay component to display the player's deck. Uses CSS Modules (`DeckView.module.css`) for styling. Accepts `deck` (array of card IDs), `gameConfig`, and `onClose` props. Renders a grid of `CardDisplay` components. **Uses a combination of card ID and array index for unique React keys to support duplicate cards in the deck.** Includes a "Close" button.
│   │   │   └── DeckView.module.css # CSS Module defining styles for the `DeckView` modal overlay, content area, and card grid.
│   │   ├── context/ # React context providers for managing global state.
│   │   │   └── GameContext.tsx # Manages the WebSocket connection to the game server, triggered by the `privyId` from `useGamesFun`. Establishes the connection (using `ws://localhost:3001`), sends a 'register' message upon opening, and handles incoming messages: 'init' (sets initial `GameState` and `GameConfig`), 'state_update' (updates `GameState`), and 'error'. When handling 'state_update', it checks if the `turn` property has changed compared to the previous state. If the turn has changed, it introduces an artificial delay using `setTimeout` before updating the local `gameState`. Includes cleanup logic.
│   │   └── ... (other components, contexts, etc.)
│   ├── index.html # Main HTML entry point for the single-page application.
│   ├── package.json # Defines client dependencies (e.g., `react`, `@privy-io/react-auth`, `@games-fun/react`) and npm scripts (e.g., `dev`, `build`).
│   ├── tsconfig.json # TypeScript configuration specific to the client application.
│   └── ... (other Vite config files) # Configuration for the Vite build tool.
├── server/ # Backend Node.js application - Manages game logic, state persistence per player, action validation, and WebSocket communication with clients.
│   ├── node_modules/ # Project dependencies for the server (Express, WebSocket library, etc.).
│   ├── src/ # Server-side source code (TypeScript).
│   │   ├── config.ts # Stores static game configuration constants (e.g., `PLAYER_MAX_HP`, `PLAYER_START_ENERGY`, `MOMENTUM_PER_CARD`, reward counts) used for balancing and defining core game rules.
│   │   ├── data/ # Contains static data definitions for game elements.
│   │   │   ├── cards.ts # Defines all available cards in the game, including their cost, effects (as an array of `CardEffect`), and description. Card images are derived from the card `id` (e.g., `id: 'strike'` corresponds to `strike.png`). Exports a `cards` object mapping card IDs to `CardDefinition`. **Includes basic starting cards (like 'strike', 'defend') and non-basic cards (like 'bash', 'quick_slash') which can be offered as rewards.** Card effects can now include `{ type: 'applyBuff', buffType: 'buff_id', buffStacks: 1 }`.
│   │   │   ├── enemies.ts # Defines the base stats (`maxHp`, `maxEnergy`) and decks for all enemy types. Enemy images are derived from the enemy `id`. Exports an `enemies` object mapping enemy IDs to `EnemyDefinition`.
│   │   │   └── buffs.ts # Defines the static properties (id, name, description) for all buffs/debuffs in the game. Exports a `buffs` object mapping buff IDs to `BuffDefinition`.
│   │   ├── types.ts # Contains all shared TypeScript type definitions and interfaces for game entities (e.g., `CardEffect`, `CardDefinition`, `Buff`, `CombatantState`, `PlayerState`, `EnemyState`, `EnemyDefinition`, `GameState`, `GameConfig`) and actions (`ActionRequest`). Ensures type safety across the server codebase and consistency with client expectations. `CombatantState` includes `id`, `name`, `hp`, `maxHp`, `block`, `momentum`, `buffs: Buff[]`. `PlayerState` extends `CombatantState`, adding `energy`, `maxEnergy`, `deck: string[]` (draw pile), `discard: string[]`, `nextCard: string | null` (stores the ID of the card to be played automatically), and `allCards: string[]` (full collection). `GameState.phase` includes `'pre_battle'`, `'fighting'`, `'reward'`, `'gameOver'`. `GameConfig` includes `cards: Record<string, CardDefinition>`, `enemies: Record<string, EnemyDefinition>`, `buffs: Record<string, BuffDefinition>`, and constants. `ActionRequest` defines `{ type: ValidActionType, payload?: any }`. **'endTurn' is not a valid action type.**
│   │   ├── gameManager.ts # Implements the core game logic and state management using the `DefaultGameManager` class. It holds the game state for active players (`playerStates` map). Key methods include:
│   │   │   - `getState(playerId)`: Retrieves or initializes `GameState`.
│   │   │   - `setState(playerId, state)`: Updates stored `GameState`.
│   │   │   - `validateAction(playerId, action: ActionRequest)`: Validates and processes player actions.
│   │   │     - For `'autoPlayCard'`: Checks turn, phase ('fighting'), existence and validity of `player.nextCard` (string ID), looks up the `CardDefinition`, checks energy. If valid: deducts energy, calls `applyCardEffects`, adds momentum, pushes the **card ID** to `discard`, sets `nextCard` to null, calls `drawCard` to set the new `nextCard` ID. **Crucially, it then checks if the player can afford the *newly drawn* `nextCard`. If the player has insufficient energy for the new card, or if no card could be drawn, it then applies end-of-turn effects (buff ticks, block reset, momentum reset) and sets `state.turn` to `'enemy'`. Otherwise, if the player *can* afford the next card, the turn remains `'player'`.** Calls `checkCombatEnd` after playing the card and applying effects. Updates state. Returns success/failure.
│   │   │     - For `'selectReward'`: Checks phase ('reward'), `payload.cardIndex`. If valid and not skipping (-1), finds the chosen `CardDefinition` from `rewardOptions`, adds its **ID** to `player.discard` and `player.allCards`. Increments `currentRewardSet`. If all sets complete: clears rewards, sets phase to 'fighting', calls `startNewFight`, calls `drawCard` to set the first `nextCard` ID for the new fight, updates state, returns success.
│   │   │     - For `'startBattle'`: Checks phase ('pre_battle'). If valid: changes phase to 'fighting', calls `drawCard` to set the initial `nextCard` ID, updates state, returns success.
│   │   │     - `'newGame'` placeholder returns success.
│   │   │   - `applyCardEffects(cardDef, caster, target, gameState)`: Applies effects from a `CardDefinition`. Handles 'damage' (accounts for block), 'block', 'drawCard' (calls `drawCard` for player), 'gainEnergy' (for player), 'applyBuff' (calls `applyBuff`).
│   │   │   - `applyBuff(target, buffDef, stacks, duration)`: Adds/updates buffs in `target.buffs`. Handles stacking and duration. Removes buffs if stacks <= 0.
│   │   │   - `runEnemyTurn(gameState)`: Executes enemy turn. Calls `applyStartOfTurnBuffs`. Plays first card from enemy deck via `applyCardEffects`. Sets `gameState.lastEnemyCardPlayedId`. Calls `checkCombatEnd`. If combat continues, calls `applyEndOfTurnBuffs` and sets turn to 'player'.
│   │   │   - `applyStartOfTurnBuffs(combatant)`: Applies start-of-turn buff effects (placeholder).
│   │   │   - `applyEndOfTurnBuffs(combatant)`: Applies end-of-turn effects, ticks down durations, removes expired/depleted buffs, resets block.
│   │   │   - `startNewFight(gameState)`: Handles setup for the next fight. Selects next enemy based on floor, resets enemy state. **Resets player's `deck` from `allCards` (array of IDs), clears `discard`, clears `nextCard`, shuffles `deck`. Resets player block/momentum.** Modifies the passed state. (Does *not* draw the first card - that happens in `validateAction` for `selectReward` or `startBattle`).
│   │   │   - `generateRewards(gameState)`: Populates `gameState.rewardOptions` with non-basic `CardDefinition` choices after enemy defeat. Uses constants for number of sets/choices.
│   │   │   - `checkCombatEnd(state)`: Checks HP. Player loss sets phase 'gameOver', calculates currency. Enemy defeat sets phase 'reward', increments floor, calls `generateRewards`, resets `currentRewardSet`, resets player combat stats (block, momentum, buffs), sets turn to player. Modifies state directly.
│   │   │   - `initializeNewGameState(playerId)`: Creates initial `GameState`. Sets floor 1, currency 0, initial player state (using constants for HP/Energy, starting deck IDs), first enemy, phase 'pre_battle'. Shuffles the initial player deck. Does *not* draw the first card.
│   │   │   - `drawCard(playerState)`: If deck empty, shuffles discard into deck, adds momentum. Takes **card ID** from top of `deck`. Sets `playerState.nextCard` to the **ID string**.
│   │   │   - `shuffleDeck(playerState)`: Moves `discard` (array of IDs) to `deck` (if discard not empty), shuffles `deck` (Fisher-Yates). Clears `discard`. If discard empty, shuffles existing deck.
│   │   │ It uses the `GameConfig` provided during instantiation.
│   │   └── index.ts # Main server entry point. Initializes Express, HTTP server, WebSocket (`ws`). Enables CORS, JSON parsing. Loads config, instantiates `DefaultGameManager`. Handles WebSocket connections ('connection', 'register', 'close', 'error'). Sends 'init' message. Defines HTTP endpoints: `GET /api/config`, `GET /api/state/:playerId`, `POST /api/validate-action`. **The `/api/validate-action` handler awaits `gameManager.validateAction`. If successful and not game over, it checks the resulting `gameState.turn`. If the turn is now `'enemy'` (because the player couldn't afford their next card), it calls `gameManager.runEnemyTurn(gameState)`. If the turn switches back to `'player'` after the enemy turn, it resets player energy and applies start-of-turn buffs.** Broadcasts the final `GameState` ('state_update').** Returns validation result via HTTP.
│   ├── package.json # Server dependencies and scripts. Includes `cors` dependency.
│   └── tsconfig.json # Server TypeScript configuration.
├── instructions.md # This file - Provides an up-to-date, detailed overview of the project, file structure explanations, descriptions of key functions/modules, and potentially setup/run instructions for development.
└── readme.md # Project README - Standard README file containing a high-level project description, basic setup instructions, and usage guidelines. **(Needs update for current gameplay flow).**

## Additional instructions
After reading the instructions you should answer with the files that I should provide you for context to answer the question