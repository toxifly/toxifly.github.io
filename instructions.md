# Project Instructions

## Overview

This project is a web-based card game, likely a roguelike deck-builder, involving a client (built with React/Vite) and a server (built with Node.js/Express/WebSocket) potentially using the Games Fun SDK. The client handles presentation and user interaction, while the server manages game state, logic, and rules.

## File Structure
.
├── client/ # Frontend React application (Vite) - Responsible for displaying the game state received from the server and sending user actions back.
│   ├── node_modules/ # Project dependencies for the client (React, Vite plugins, etc.).
│   ├── public/ # Static assets accessible directly by the browser (e.g., favicon, initial images).
│   ├── src/    # Client-side source code (React components, context providers, API/WebSocket communication logic, styles).
│   │   ├── App.tsx # The main application component. It wraps the application with `GamesFunProvider` from `@games-fun/react`. **It configures the provider using `GamesFunProviderProps`, setting `debug: true`, enabling `dev` mode, and crucially specifying `gameServerUrl: 'http://localhost:3001/api/validate-action'` to ensure the SDK sends action validation requests to the correct backend endpoint.** It also wraps the core `Game` component with the `GameProvider` for WebSocket context.
│   │   ├── Game.tsx # The core component responsible for rendering the game interface. Uses `useGame` for state/config and `useGamesFunActions` for actions. Manages loading/error/connection states via early returns. Conditionally renders UI based on `gameState.phase` (renders `GameUI` for 'pre_battle' and 'fighting', `RewardScreen` for 'reward', and a 'Game Over' display for 'gameOver' showing floor and currency). Handles the 'pre_battle' phase by rendering the core UI and the `ActionPanel` component. It includes logic to automatically play the player's next card (`actions.autoPlayCard`) after a delay when it's their turn (using `useRef` to access fresh state within the timeout). It manages an `animatingCardId` state to trigger a CSS animation on the card being played and passes this state down to `GameUI`. **Renders the `ActionPanel` component, passing required state, actions, and a handler (`onViewDeck`) to toggle deck visibility. Manages an `isDeckVisible` state to conditionally render the `DeckView` modal overlay, passing the player's full deck, game config, and a close handler.**
│   │   ├── components/ # Reusable UI components.
│   │   │   ├── GameUI.tsx # The main UI displayed during the 'fighting' phase (and partially in 'pre_battle'). Takes the current `GameState` and arranges the `PlayerDisplay`, `EnemyDisplay`, and `CardDisplay` components. Accepts `animatingCardId` prop and passes `isBeingPlayed` to `CardDisplay` for the next card based on matching the ID.
│   │   │   ├── CombatantDisplay.tsx # Displays core combatant stats (HP, Block, Momentum) and any active buffs/debuffs (using BuffIcon) based on a CombatantState object. Intended for reuse by PlayerDisplay and EnemyDisplay. Displays buffs from `combatant.buffs` array.
│   │   │   ├── PlayerDisplay.tsx # Displays the player's specific stats, leveraging the CombatantDisplay component and adding player-specific information like energy. Takes a `PlayerState` object as a prop.
│   │   │   ├── EnemyDisplay.tsx # Displays the enemy's stats by wrapping CombatantDisplay. It adds a specific background image for the enemy based on `enemy.id` (from `public/images/enemies/`). Takes an `EnemyState` object as a prop.
│   │   │   ├── BuffIcon.tsx # Displays an icon for a given Buff, showing its name, description, stacks, and duration on hover. Uses images from `public/images/buffs/` based on the buff ID.
│   │   │   ├── CardDisplay.tsx # Renders a single card based on `CardDefinition`. Displays cost, name, description, and image. Now uses CSS Modules (`CardDisplay.module.css`) for styling. Accepts `isNextCard` and `isBeingPlayed` props. The `isBeingPlayed` prop triggers a CSS animation defined in the module.
│   │   │   ├── CardDisplay.module.css # CSS Module defining styles and a `playCardAnimation` keyframe animation for the `CardDisplay` component. Includes base styles, `nextCard` highlight, and `playing` animation class.
│   │   │   ├── RewardScreen.tsx # Displays the card reward options presented to the player after winning a fight (when `gameState.phase === 'reward'`). It fetches the current reward set from `gameState.rewardOptions[gameState.currentRewardSet]` via the `useGame` hook. It uses the `CardDisplay` component to show each card choice. Clicking a card or the "Skip Reward" button triggers the `actions.selectReward` function (obtained via `useGamesFunActions`) with the appropriate `cardIndex` payload. Includes basic inline styling for layout.
│   │   │   ├── ActionPanel.tsx # Renders buttons for player actions outside the main card play area (e.g., fixed position panel). Accepts `gameState`, `actions` (from `useGamesFunActions`), and `onViewDeck` (from `Game.tsx`) as props. Conditionally renders a "Start Battle" button when `gameState.phase === 'pre_battle'`, which calls `actions.startBattle()`. **Includes a "View Deck" button which calls the `onViewDeck` prop function to signal `Game.tsx` to show the `DeckView` modal.** Includes basic inline styles for layout and positioning.
│   │   │   ├── ActionPanel.module.css # **(New)** CSS Module defining styles for the `ActionPanel` component.
│   │   │   ├── DeckView.tsx # A modal/overlay component to display the player's deck. Uses CSS Modules (`DeckView.module.css`) for styling. Accepts `deck`, `gameConfig`, and `onClose` props. Renders a grid of `CardDisplay` components. Includes a "Close" button.
│   │   │   └── DeckView.module.css # **(New)** CSS Module defining styles for the `DeckView` modal overlay, content area, and card grid.
│   │   ├── context/ # React context providers for managing global state.
│   │   │   └── GameContext.tsx # Manages the WebSocket connection to the game server, triggered by the `privyId` from `useGamesFun`. Establishes the connection, sends a 'register' message upon opening, and handles incoming messages: 'init' (sets initial `GameState` and `GameConfig`), 'state_update' (updates `GameState`), and 'error'. Manages connection state (`isConnected`, `error`) and provides the game state, config, connection status, and a `sendMessage` function to child components via the `useGame` hook. Includes cleanup logic to close the WebSocket on disconnect or component unmount.
│   │   └── ... (other components, contexts, etc.)
│   ├── index.html # Main HTML entry point for the single-page application.
│   ├── package.json # Defines client dependencies (e.g., `react`, `@privy-io/react-auth`, `@games-fun/react`) and npm scripts (e.g., `dev`, `build`).
│   ├── tsconfig.json # TypeScript configuration specific to the client application.
│   └── ... (other Vite config files) # Configuration for the Vite build tool.
├── server/ # Backend Node.js application - Manages game logic, state persistence per player, action validation, and WebSocket communication with clients.
│   ├── node_modules/ # Project dependencies for the server (Express, WebSocket library, etc.).
│   ├── src/ # Server-side source code (TypeScript).
│   │   ├── config.ts # Stores static game configuration constants (e.g., `PLAYER_MAX_HP`, `PLAYER_START_ENERGY`, `MOMENTUM_PER_CARD`, reward counts) used for balancing and defining core game rules.
│   │   ├── data/ # Contains static data definitions for game elements.
│   │   │   ├── cards.ts # Defines all available cards in the game, including their cost, effects (as an array of `CardEffect`), and description. Card images are derived from the card `id` (e.g., `id: 'strike'` corresponds to `strike.png`). Exports a `cards` object mapping card IDs to `CardDefinition`. Card effects can now include `{ type: 'applyBuff', buffType: 'buff_id', buffStacks: 1 }`.
│   │   │   ├── enemies.ts # Defines the base stats (`maxHp`, `maxEnergy`) and decks for all enemy types. Enemy images are derived from the enemy `id`. Exports an `enemies` object mapping enemy IDs to `EnemyDefinition`.
│   │   │   └── buffs.ts # Defines the static properties (id, name, description) for all buffs/debuffs in the game. Exports a `buffs` object mapping buff IDs to `BuffDefinition`.
│   │   ├── types.ts # Contains all shared TypeScript type definitions and interfaces for game entities (e.g., `CardEffect`, `CardDefinition`, `Buff`, `CombatantState`, `PlayerState`, `EnemyState`, `EnemyDefinition`, `GameState`, `GameConfig`) and actions (`ActionRequest`). Exports the `BuffDefinition` type (`Omit<Buff, 'stacks' | 'duration'>`). Ensures type safety across the server codebase and consistency with client expectations. `CombatantState` includes a `buffs: Buff[]` array to hold active buffs. `GameConfig` includes `buffs: Record<string, BuffDefinition>` to hold buff definitions. `Buff` interface defines the structure of an active buff instance (id, name, description, duration, stacks). **`GameState.phase` includes `'pre_battle'` (the initial phase before the first fight starts, allowing deck view and starting the battle).** `PlayerState` includes `allCards: string[]` to track the player's full deck throughout the run. **`ActionRequest` includes `{ type: 'startBattle' }` (used to transition from 'pre_battle' to 'fighting', triggered by the `ActionPanel` button).**
│   │   ├── gameManager.ts # Implements the core game logic and state management using the `DefaultGameManager` class. It holds the game state for active players (`playerStates` map). Key methods include:
│   │   │   - `getState(playerId)`: Retrieves the current `GameState` for a player. If no state exists, it calls `initializeNewGameState` to create one.
│   │   │   - `setState(playerId, state)`: Updates the stored `GameState` for a player.
│   │   │   - `validateAction(playerId, action)`: Validates and processes player actions.
│   │   │     - For `'autoPlayCard'`: Checks turn, phase ('fighting'), card existence (`nextCard`), and energy. If valid, executes card play: deducts energy, calls `applyCardEffects`, adds momentum, moves card to discard, draws next card. If momentum cap is reached, calls `applyEndOfTurnBuffs(player)` before switching turn. Calls `checkCombatEnd`, updates state, returns success.
│   │   │     - For `'endTurn'`: Checks turn/phase ('fighting'). If valid, calls `applyEndOfTurnBuffs(player)`, resets player momentum, sets turn to `'enemy'`, updates state, returns success.
│   │   │     - For `'selectReward'`: Checks phase ('reward') and `cardIndex`. If valid and not skipping, adds card ID to `player.discard` and `player.allCards`. Increments `gameState.currentRewardSet`. If all reward sets complete, clears rewards, **sets phase back to 'fighting' (implicitly starting next floor logic)**, calls `startNewFight`, draws the first card, updates state, returns success. **(The flow proceeds automatically after rewards, no manual "Next Floor" action is needed).**
│   │   │     - **For `'startBattle'`: Checks if phase is `'pre_battle'`. If valid, changes phase to `'fighting'`, calls `drawCard` to draw the initial card for the fight, updates state, returns success. This action transitions the game from the initial state into active combat.**
│   │   │     - Other action validations (`'newGame'`) are currently placeholders returning success.
│   │   │   - `applyCardEffects(...)`: Applies card effects. Handles 'damage', 'block', 'drawCard', 'gainEnergy'. Now handles 'applyBuff': looks up buff definition in `config.buffs`, calls helper `applyBuff(target, buffDef, stacks, duration)` to add/update buff on target.
│   │   │   - `applyBuff(target, buffDef, stacks, duration)`: Adds a new buff instance to `target.buffs` or updates stacks/duration of an existing buff based on ID match. Handles potential removal if stacks drop <= 0.
│   │   │   - `runEnemyTurn(gameState)`: Executes the enemy's turn. Calls `applyStartOfTurnBuffs(enemy)` at the beginning. Plays the first card from enemy deck via `applyCardEffects`. Checks combat end. Calls `applyEndOfTurnBuffs(enemy)` before potentially switching turn back to player.
│   │   │   - `applyStartOfTurnBuffs(combatant)`: Public method (called by `runEnemyTurn` for enemy, and by `index.ts` for player) to apply effects of buffs that trigger at the start of a turn. (Currently placeholder logic).
│   │   │   - `applyEndOfTurnBuffs(combatant)`: Applies end-of-turn effects (like poison damage - placeholder). Ticks down `duration` for non-permanent buffs. Removes buffs if `duration <= 0` or `stacks <= 0`. Resets combatant's `block` to 0.
│   │   │   - `startNewFight(gameState)`: Handles setup for the next fight. Called after rewards are selected (via `selectReward`). Determines next enemy based on `gameState.floor`, creates new `EnemyState`, updates `gameState.enemy`. Modifies the passed state object directly.
│   │   │   - `generateRewards(gameState)`: Called when an enemy is defeated (within `checkCombatEnd`). Populates `gameState.rewardOptions`. Selects `config.REWARD_CHOICES_COUNT` unique non-basic cards, repeated `config.REWARD_SETS` times. Modifies the passed state object directly.
│   │   │   - `checkCombatEnd(state)`: Checks if player HP <= 0 (sets phase to 'gameOver', calculates `gameState.currency`) or enemy HP <= 0 (sets phase to 'reward'). If enemy defeated, increments `gameState.floor`, calls `generateRewards`, sets `gameState.currentRewardSet` to 0, resets player stats/buffs, sets turn to player. Only runs if phase is 'fighting'. Modifies the passed state object directly.
│   │   │   - `initializeNewGameState(playerId)`: Creates initial `GameState`: floor 1, currency 0, initial player stats/deck (from config), first enemy (from data), **sets phase to `'pre_battle'`**, shuffles deck. Initializes player/enemy `buffs` to `[]`, populates `player.allCards`. **Does *not* draw the first card for combat (this now happens via the `startBattle` action).**
│   │   │   - `drawCard(playerState)`: Draws next card. If deck empty, shuffles discard into deck (using `shuffleDeck`), adds momentum, then draws. Sets `playerState.nextCard`. Handles edge cases.
│   │   │   - `shuffleDeck(playerState)`: Moves discard pile to deck, shuffles deck (Fisher-Yates), clears discard.
│   │   │ It uses the `GameConfig` provided during instantiation.
│   │   └── index.ts # Main server entry point. Initializes Express, HTTP server, WebSocket (`ws`). **Enables CORS middleware (`app.use(cors())`) to allow requests from the frontend.** Loads `buffs` into `GameConfig`. Instantiates `DefaultGameManager`. Handles WebSocket connections ('connection', 'register', 'close', 'error'). Sends 'init' message with `GameState` and `GameConfig`. Defines HTTP endpoints:
│   │   │   - `GET /api/config`: Returns static `GameConfig`.
│   │   │   - `GET /api/state/:playerId`: Returns current `GameState`, initializing if needed.
│   │   │   - `POST /api/validate-action`: Async handler. Calls `await gameManager.validateAction(...)`. If successful: retrieves updated `GameState`, **checks if `gameState.turn` is now `'enemy'` and calls `gameManager.runEnemyTurn(gameState)` if so**, broadcasts final `GameState` via WebSocket ('state_update'), returns original validation result.
│   ├── package.json # Server dependencies and scripts. **Includes `cors` dependency.**
│   └── tsconfig.json # Server TypeScript configuration.
├── instructions.md # This file - Provides an up-to-date, detailed overview of the project, file structure explanations, descriptions of key functions/modules, and potentially setup/run instructions for development.
└── readme.md # Project README - Standard README file containing a high-level project description, basic setup instructions, and usage guidelines, suitable for external viewers or as a quickstart guide. **(Needs update for 'Start Battle' and 'View Deck' flow).**