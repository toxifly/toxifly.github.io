# Project Instructions

## Overview

This project is a web-based card game, likely a roguelike deck-builder, involving a client (built with React/Vite) and a server (built with Node.js/Express/WebSocket) potentially using the Games Fun SDK. The client handles presentation and user interaction, while the server manages game state, logic, and rules. **The player's turn proceeds automatically, playing cards sequentially as long as the player has enough energy for the `nextCard`. The turn only ends and passes to the enemy when the player cannot afford the cost of their `nextCard` or has no cards left to draw.**
Update this file every time you edit something or you notice that the content is different than what you'd expect based on this description.

## File Structure
.
├── client/ # Frontend React application (Vite) - Responsible for displaying the game state received from the server and sending user actions back.
│   ├── node_modules/ # Project dependencies for the client (React, Vite plugins, etc.).
│   ├── public/ # Static assets accessible directly by the browser (e.g., favicon, initial images, enemy backgrounds, card images, buff icons).
│   │   ├── images/
│   │   │   ├── backgrounds/ # Background images (e.g., enemy_background.png)
│   │   │   ├── buffs/ # Buff icons (e.g., strength.png)
│   │   │   ├── cards/ # Card artwork (e.g., strike.png)
│   │   │   └── enemies/ # Enemy sprites (e.g., goblin.png)
│   │   └── ... (other public assets)
│   ├── src/    # Client-side source code (React components, context providers, API/WebSocket communication logic, styles).
│   │   ├── App.tsx # The main application component. It wraps the application with `GamesFunProvider` from `@games-fun/react`. **It configures the provider using `GamesFunProviderProps`, setting `debug: true`, enabling `dev` mode, and crucially specifying `gameServerUrl: 'http://localhost:3001/api/validate-action'` to ensure the SDK sends action validation requests to the correct backend endpoint.** It also wraps the core `Game` component with the `GameProvider` for WebSocket context.
│   │   ├── Game.tsx # The core component responsible for rendering the game interface. Uses `useGame` for state/config and `useGamesFunActions` for actions. Manages loading/error/connection states via early returns. Conditionally renders UI based on `gameState.phase` (renders `GameUI` for 'pre_battle' and 'fighting', `RewardScreen` for 'reward', and a 'Game Over' display for 'gameOver' showing floor and currency). **Renders the dark-themed `GameUI` during 'fighting' and 'pre_battle'.** **Handles the 'pre_battle' phase by rendering the core UI and the `ActionPanel` component.** **It includes a `useEffect` hook (dependent on `gameState`, `gameConfig`, and `actions`) to automatically trigger the player's next card play (`actions.autoPlayCard`) after a delay (e.g., 1200ms). This effect triggers when it's the player's turn, they are in the 'fighting' phase, they have a `nextCard` ID (string) available in `gameState.player`, and have sufficient energy for that card. If the server successfully processes the card play and the player *still* has enough energy for the *new* `nextCard`, the `gameState` update will re-trigger this effect, allowing for consecutive card plays within the same logical turn. The effect uses a `useRef` (`gameStateRef`) to capture the latest state for the timeout callback and another `useRef` (`timeoutRef`) along with a robust cleanup function to clear pending timeouts, preventing concurrent or stale actions. The `animatingCardId` state (storing the string card ID) is set before the timeout is scheduled to initiate animation early; this ID is passed down to `GameUI`. Inside the `setTimeout` callback, it re-validates the game state conditions (phase, turn, next card ID, energy) using the `gameStateRef` before calling the `autoPlayCard` action. A `finally` block ensures `animatingCardId` is reset.** Includes extensive console logging for effect triggers, conditions, timeouts, and actions. Renders the `ActionPanel` component, passing down state, actions, and a function to toggle `DeckView` visibility. Manages `isDeckVisible` state for the `DeckView` modal and renders it conditionally. Includes a helper function `renderLoadingOrConnectionStatus` to handle various loading and error states. **Removes the main 'Game Active - Player...' `<h1>` heading. Instead, displays player ID, floor, and turn as small text positioned absolutely at the top-left of the main container.**
│   │   ├── components/ # Reusable UI components.
│   │   │   ├── GameUI.tsx # The main UI displayed during the 'fighting' phase (and partially in 'pre_battle'). Takes `GameState` and `animatingCardId`. **Uses CSS for layout and dark theme. Arranges components vertically: Floor Indicator -> `EnemyDisplay` -> `PlayerDisplay` -> Card Area. Fetches `gameConfig` using `useGame`. Looks up the `CardDefinition` for the player's playable card (`gameState.player.nextCard`) and the *next* card to be drawn (`gameState.player.deck[0]`). Passes these definitions to `CardDisplay` components (one for playable card, one for next draw preview) arranged **side-by-side** within the `.card-area` (styled in `App.css`). Determines `isBeingPlayed` for the playable card based on `animatingCardId`. **Derives `maxMomentum` from `gameConfig` (or defaults) and passes it down to both `EnemyDisplay` and `PlayerDisplay`.** Does *not* render the `ActionLog`.** Uses CSS classes (e.g., `.game-ui-container`, `.floor-indicator`, `.card-area`) for structure. **Does NOT use wrapper divs like `.enemy-section` or `.player-section` anymore; these components are direct children of `.game-ui-container`.**
│   │   │   ├── CombatantDisplay.tsx # Displays core combatant stats (HP, Block, Momentum) and buffs based on a `CombatantState`. Used by `PlayerDisplay` and `EnemyDisplay`. **Accepts `maxMomentum` prop and displays Momentum as `current / max`.** **Assumes CSS classes will handle stat layout (e.g., `.stat-row`, `.stat-label`, `.stat-value`) and buff layout (e.g., `.buff-display`).**
│   │   │   ├── PlayerDisplay.tsx # Displays the player's stats. **Uses `PlayerDisplay.css` for styling. Displays player name on the left and stats (HP, Block, Energy, Momentum) on the right within a dark-themed container with a blue border. Accepts `maxMomentum` prop from parent and displays Momentum accordingly. Uses `CombatantDisplay` for rendering buffs (and potentially other common stats), passing down the `player` object and `maxMomentum`.** Takes `PlayerState` and `maxMomentum` as props.
│   │   │   ├── PlayerDisplay.css # **CSS styles for `PlayerDisplay`, defining the dark theme container (dark blueish background, blue border, `width: 100%`, `max-width: 1800px` [increased], centered within its parent via `margin: auto`), name/stats layout (name left, stats right), and stat formatting (monospace font, light text colors).**
│   │   │   ├── EnemyDisplay.tsx # Displays the enemy's stats. **Uses `EnemyDisplay.css` for styling. Uses the specific enemy's image as the background for the *entire* component container (`background-image` and `background-size: cover` set inline). The stats (via `CombatantDisplay`) are shown in an info box aligned to the right using flexbox (no longer absolutely positioned). Does *not* show the last played enemy card or a duplicate enemy name heading.** Accepts `enemy: EnemyState` and `maxMomentum: number` props. Passes `enemy` and `maxMomentum` to `CombatantDisplay`.
│   │   │   ├── EnemyDisplay.css # **CSS styles for `EnemyDisplay`, defining the outer container (`width: 100%`, `max-width: 1800px` [increased], purple border, `background-position: center center`, uses flexbox for layout). Defines the layout and styling for the info box (`.enemy-info-container` aligned to the end/right, `max-width: 350px`, adjusted transparency `rgba(40, 10, 60, 0.85)`). `background-size` is handled inline in the component.**
│   │   │   ├── ActionLog.tsx # **Displays a scrollable log of game actions. Not currently rendered in `GameUI`. Uses inline styles for a dark, monospace-themed appearance. Expects an array of log strings as props.**
│   │   │   ├── BuffIcon.tsx # Displays an icon for a given Buff, showing its name, description, stacks, and duration on hover. Uses images from `public/images/buffs/` based on the buff ID.
│   │   │   ├── CardDisplay.tsx # Renders a single card based on `CardDefinition`. **Uses CSS Modules (`CardDisplay.module.css`) for dark theme styling. Accepts `card`, `isNextCard` (highlights playable card), `isBeingPlayed` (triggers play animation), and `isNextDrawPreview` (scales card down for the next draw preview). Includes image fallback.**
│   │   │   ├── CardDisplay.module.css # CSS Module defining styles for `CardDisplay`. **Includes dark theme base styles (dark gradient background, borders, fonts), `.nextCard` highlight (brighter border/shadow), `.playing` animation, and `.nextDrawPreview` scaling/styling class.**
│   │   │   ├── RewardScreen.tsx # Displays card reward options after winning a fight. Uses `CardDisplay`. Triggers `actions.selectReward`. **(Needs style update for dark theme).**
│   │   │   ├── ActionPanel.tsx # Renders buttons for player actions (Start Battle, View Deck). **Positioned on the right side of the screen. Uses `ActionPanel.module.css` for dark theme styling.** Accepts `gameState`, `actions`, `onViewDeck`.
│   │   │   ├── ActionPanel.module.css # CSS Module defining styles for the `ActionPanel` component. **Updated for dark theme (dark background, grey border) and button appearance (dark buttons, monospace font, uppercase text).**
│   │   │   ├── DeckView.tsx # Modal overlay to display the player's deck. Uses `CardDisplay`. **(Needs style update for dark theme).** Accepts `deck`, `gameConfig`, `onClose`. Uses CSS Modules (`DeckView.module.css`).
│   │   │   └── DeckView.module.css # CSS Module defining styles for `DeckView`. **(Needs update for dark theme).**
│   │   ├── context/ # React context providers for managing global state.
│   │   │   └── GameContext.tsx # Manages WebSocket connection, state updates, handles 'init', 'state_update', 'error' messages. Includes logic for potential delay on turn change.
│   │   └── ... (other client files)
│   ├── styles/ # Global styles or theme configuration.
│   ├── App.css # Global CSS. **Styles `#root` with `width: 100%` and `box-sizing: border-box` to ensure it takes full viewport width, overriding potential constraints from `index.css` body flex centering. Includes layout styles for `.game-ui-container` (flex column, centered items, `max-width: 2000px` [increased], centered via `margin: auto`), `.floor-indicator`, `.enemy-section`, `.player-section` (both `width: 100%`), and `.card-area` (flex row, centered cards). Also defines styles for card placeholders.** **Does not define `.enemy-section` or `.player-section` layout beyond `width: 100%`; their children handle internal layout.**
│   ├── index.html # Main HTML entry point.
│   ├── package.json # Client dependencies and scripts.
│   ├── tsconfig.json # Client TypeScript configuration.
│   └── ... (other Vite config files)
├── server/ # Backend Node.js application - Manages game logic, state, action validation, WebSocket communication.
│   ├── node_modules/ # Server dependencies.
│   ├── src/ # Server-side source code (TypeScript).
│   │   ├── config.ts # Stores static game configuration constants (e.g., `PLAYER_MAX_HP`, `PLAYER_START_ENERGY`, `MOMENTUM_PER_CARD`, reward counts) used for balancing and defining core game rules. **Should define `MAX_MOMENTUM`.**
│   │   ├── data/ # Contains static data definitions for game elements.
│   │   │   ├── cards.ts # Defines all available cards in the game, including their cost, effects (as an array of `CardEffect`), and description. Card images are derived from the card `id` (e.g., `id: 'strike'` corresponds to `strike.png`). Exports a `cards` object mapping card IDs to `CardDefinition`. **Includes basic starting cards (like 'strike', 'defend') and non-basic cards (like 'bash', 'quick_slash') which can be offered as rewards.** Card effects can now include `{ type: 'applyBuff', buffType: 'buff_id', buffStacks: 1 }`.
│   │   │   ├── enemies.ts # Defines the base stats (`maxHp`, `maxEnergy`) and decks for all enemy types. Enemy images are derived from the enemy `id`. Exports an `enemies` object mapping enemy IDs to `EnemyDefinition`.
│   │   │   └── buffs.ts # Defines the static properties (id, name, description) for all buffs/debuffs in the game. Exports a `buffs` object mapping buff IDs to `BuffDefinition`.
│   │   ├── types.ts # Contains all shared TypeScript type definitions and interfaces for game entities (e.g., `CardEffect`, `CardDefinition`, `Buff`, `CombatantState`, `PlayerState`, `EnemyState`, `EnemyDefinition`, `GameState`, `GameConfig`) and actions (`ActionRequest`). Ensures type safety across the server codebase and consistency with client expectations. `CombatantState` includes `id`, `name`, `hp`, `maxHp`, `block`, `momentum`, `buffs: Buff[]`. `PlayerState` extends `CombatantState`, adding `energy`, `maxEnergy`, `deck: string[]` (draw pile), `discard: string[]`, `nextCard: string | null` (stores the ID of the card to be played automatically), and `allCards: string[]` (full collection). **`PlayerState` does not include `maxMomentum`.** `GameState.phase` includes `'pre_battle'`, `'fighting'`, `'reward'`, `'gameOver'`. `GameConfig` includes `cards: Record<string, CardDefinition>`, `enemies: Record<string, EnemyDefinition>`, `buffs: Record<string, BuffDefinition>`, and constants. **Should include `MAX_MOMENTUM`.** `ActionRequest` defines `{ type: ValidActionType, payload?: any }`. **'endTurn' is not a valid action type.**
│   │   ├── gameManager.ts # Implements the core game logic and state management using the `DefaultGameManager` class. It holds the game state for active players (`playerStates` map). Key methods include:
│   │   │   - `getState(playerId)`: Retrieves or initializes `GameState`.
│   │   │   - `setState(playerId, state)`: Updates stored `GameState`.
│   │   │   - `validateAction(playerId, action: ActionRequest)`: Validates and processes player actions.
│   │   │     - For `'autoPlayCard'`: Checks turn, phase ('fighting'), existence and validity of `player.nextCard` (string ID), looks up the `CardDefinition`, checks energy. If valid: deducts energy, calls `applyCardEffects`, adds momentum, pushes the **card ID** to `discard`, sets `nextCard` to null, calls `drawCard` to set the new `nextCard` ID. **Crucially, it then checks if the player can afford the *newly drawn* `nextCard`. If the player has insufficient energy for the new card, or if no card could be drawn, it then applies end-of-turn effects (buff ticks, block reset, momentum reset) and sets `state.turn` to `'enemy'`. Otherwise, if the player *can* afford the next card, the turn remains `'player'`.** Calls `checkCombatEnd` after playing the card and applying effects. Updates state. Returns success/failure.
│   │   │     - For `'selectReward'`: Checks phase ('reward'), `payload.cardIndex`. If valid and not skipping (-1), finds the chosen `CardDefinition` from `rewardOptions`, adds its **ID** to `player.discard` and `player.allCards`. Increments `currentRewardSet`. If all sets complete: clears rewards, sets phase to 'fighting', calls `startNewFight`, calls `drawCard` to set the first `nextCard` ID for the new fight, updates state, returns success.
│   │   │     - For `'startBattle'`: Checks phase ('pre_battle'). If valid: changes phase to 'fighting', calls `drawCard` to set the initial `nextCard` ID, updates state, returns success.
│   │   │     - `'newGame'` placeholder returns success.
│   │   │   - `applyCardEffects(cardDef, caster, target, gameState)`: Applies effects from a `CardDefinition`. Handles 'damage' (accounts for block), 'block', 'drawCard' (calls `drawCard` for player), 'gainEnergy' (for player), 'applyBuff' (calls `applyBuff`).
│   │   │   - `applyBuff(target, buffDef, stacks, duration)`: Adds/updates buffs in `target.buffs`. Handles stacking and duration. Removes buffs if stacks <= 0.
│   │   │   - `runEnemyTurn(gameState)`: Executes enemy turn. Calls `applyStartOfTurnBuffs`. Plays first card from enemy deck via `applyCardEffects`. Sets `gameState.lastEnemyCardPlayedId`. Calls `checkCombatEnd`. If combat continues, calls `applyEndOfTurnBuffs` and sets turn to 'player'.
│   │   │   - `applyStartOfTurnBuffs(combatant)`: Applies start-of-turn buff effects (placeholder).
│   │   │   - `applyEndOfTurnBuffs(combatant)`: Applies end-of-turn effects, ticks down durations, removes expired/depleted buffs, resets block.
│   │   │   - `startNewFight(gameState)`: Handles setup for the next fight. Selects next enemy based on floor, resets enemy state. **Resets player's `deck` from `allCards` (array of IDs), clears `discard`, clears `nextCard`, shuffles `deck`. Resets player block, momentum, buffs, and resets `energy` to `maxEnergy`.** Modifies the passed state. (Does *not* draw the first card - that happens in `validateAction` for `selectReward` or `startBattle`).
│   │   │   - `generateRewards(gameState)`: Populates `gameState.rewardOptions` with non-basic `CardDefinition` choices after enemy defeat. Uses constants for number of sets/choices.
│   │   │   - `checkCombatEnd(state)`: Checks HP. Player loss sets phase 'gameOver', calculates currency. Enemy defeat sets phase 'reward', increments floor, calls `generateRewards`, resets `currentRewardSet`, resets player combat stats (block, momentum, buffs), sets turn to player. Modifies state directly.
│   │   │   - `initializeNewGameState(playerId)`: Creates initial `GameState`. Sets floor 1, currency 0, initial player state (using constants for HP/Energy, starting deck IDs), first enemy, phase 'pre_battle'. Shuffles the initial player deck. Does *not* draw the first card.
│   │   │   - `drawCard(playerState)`: If deck empty, shuffles discard into deck, adds momentum. Takes **card ID** from top of `deck`. Sets `playerState.nextCard` to the **ID string**.
│   │   │   - `shuffleDeck(playerState)`: Moves `discard` (array of IDs) to `deck` (if discard not empty), shuffles `deck` (Fisher-Yates). Clears `discard`. If discard empty, shuffles existing deck.
│   │   │ It uses the `GameConfig` provided during instantiation.
│   │   └── index.ts # Main server entry point. Initializes Express, HTTP server, WebSocket (`ws`). Enables CORS, JSON parsing. Loads config, instantiates `DefaultGameManager`. Handles WebSocket connections ('connection', 'register', 'close', 'error'). Sends 'init' message. Defines HTTP endpoints: `GET /api/config`, `GET /api/state/:playerId`, `POST /api/validate-action`. **The `/api/validate-action` handler awaits `gameManager.validateAction`. If successful and not game over, it checks the resulting `gameState.turn`. If the turn is now `'enemy'` (because the player couldn't afford their next card), it calls `gameManager.runEnemyTurn(gameState)`. If the turn switches back to `'player'` after the enemy turn, it resets player energy and applies start-of-turn buffs.** Broadcasts the final `GameState` ('state_update').** Returns validation result via HTTP.
│   ├── package.json # Server dependencies and scripts. Includes `cors` dependency.
│   └── tsconfig.json # Server TypeScript configuration.
├── instructions.md # This file - Detailed project overview, file structure, component/module descriptions.
└── readme.md # Project README - High-level description, basic setup, usage guidelines. **(Needs update for current gameplay flow and dark theme visuals).**

## Additional instructions
After reading the instructions you should answer with the files that I should provide you for context to answer the question.
Create comprehensive descriptions of the files that would include everything anyone would need to understand which files do what and which functions they include.